"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PullFeed = exports.Aggregator = void 0;
var bn_js_1 = __importDefault(require("bn.js"));
var on_demand_1 = require("@switchboard-xyz/on-demand");
var index_js_1 = require("../index.js");
var ts_sdk_1 = require("@aptos-labs/ts-sdk");
var common_1 = require("@switchboard-xyz/common");
var Aggregator = /** @class */ (function () {
    function Aggregator(client, address) {
        this.client = client;
        this.address = address;
    }
    Aggregator.initTx = function (client, sender, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, switchboardAddress, oracleQueue, transaction;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, client.fetchState(options)];
                    case 1:
                        _a = _b.sent(), switchboardAddress = _a.switchboardAddress, oracleQueue = _a.oracleQueue;
                        return [4 /*yield*/, client.aptos.transaction.build.simple({
                                sender: sender,
                                data: {
                                    function: "".concat(switchboardAddress, "::aggregator_init_action::run"),
                                    functionArguments: [
                                        oracleQueue,
                                        options.name,
                                        Array.from(Buffer.from(options.feedHash.slice(2), "hex")),
                                        options.minSampleSize,
                                        options.maxStalenessSeconds,
                                        options.maxVariance,
                                        options.minResponses,
                                    ],
                                },
                            })];
                    case 2:
                        transaction = _b.sent();
                        return [2 /*return*/, transaction];
                }
            });
        });
    };
    /**
     * Set configs for the Aggregator
     * @param tx - Transaction
     * @param options - AggregatorConfigParams
     */
    Aggregator.prototype.setConfigsTx = function (sender, options) {
        return __awaiter(this, void 0, void 0, function () {
            var switchboardAddress, transaction;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.client.fetchState(options)];
                    case 1:
                        switchboardAddress = (_a.sent()).switchboardAddress;
                        return [4 /*yield*/, this.client.aptos.transaction.build.simple({
                                sender: sender,
                                data: {
                                    function: "".concat(switchboardAddress, "::aggregator_set_configs_action::run"),
                                    functionArguments: [
                                        this.address,
                                        options.name,
                                        Array.from(Buffer.from(options.feedHash.slice(2), "hex")),
                                        options.minSampleSize,
                                        options.maxStalenessSeconds,
                                        options.maxVariance,
                                        options.minResponses,
                                    ],
                                },
                            })];
                    case 2:
                        transaction = _a.sent();
                        return [2 /*return*/, transaction];
                }
            });
        });
    };
    /**
     * Set the feed authority
     * @param tx - Transaction
     * @param options - AggregatorSetAuthorityParams
     */
    Aggregator.prototype.setAuthorityTx = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var switchboardAddress, transaction;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.client.fetchState(options)];
                    case 1:
                        switchboardAddress = (_a.sent()).switchboardAddress;
                        return [4 /*yield*/, this.client.aptos.transaction.build.simple({
                                sender: options.newAuthority,
                                data: {
                                    function: "".concat(switchboardAddress, "::aggregator_set_authority_action::run"),
                                    functionArguments: [this.address, options.newAuthority],
                                },
                            })];
                    case 2:
                        transaction = _a.sent();
                        return [2 /*return*/, transaction];
                }
            });
        });
    };
    /**
     * Fetch the update transaction
     * @param sender - Sender
     * @param options - AggregatorFetchUpdateIxParams
     * @returns - FetchUpdateTxResponse
     */
    Aggregator.prototype.fetchUpdate = function (sender, options) {
        return __awaiter(this, void 0, void 0, function () {
            var switchboardAddress, oracleQueue, feedConfigs, aggregatorData, aptosQueue, queue, solanaQueue, crossbarClient, jobs, fetchUpdateData, fetchUpdateDataRetries, fetchUpdateDataResponse, e_1;
            var _this = this;
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.client.fetchState(options)];
                    case 1:
                        switchboardAddress = (_c.sent()).switchboardAddress;
                        feedConfigs = options === null || options === void 0 ? void 0 : options.feedConfigs;
                        if (!!feedConfigs) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.loadData()];
                    case 2:
                        aggregatorData = _c.sent();
                        oracleQueue = aggregatorData.queue;
                        feedConfigs = {
                            minSampleSize: aggregatorData.minSampleSize,
                            feedHash: aggregatorData.feedHash,
                            maxVariance: aggregatorData.maxVariance,
                            minResponses: aggregatorData.minResponses,
                        };
                        _c.label = 3;
                    case 3:
                        if (!oracleQueue) {
                            throw new Error("[fetchUpdateTx]: ORACLE QUEUE NOT FOUND");
                        }
                        aptosQueue = index_js_1.aptosQueueCache.get(oracleQueue);
                        if (!!aptosQueue) return [3 /*break*/, 5];
                        return [4 /*yield*/, new index_js_1.Queue(this.client, oracleQueue).loadData()];
                    case 4:
                        queue = _c.sent();
                        index_js_1.aptosQueueCache.set(oracleQueue, queue);
                        aptosQueue = queue;
                        _c.label = 5;
                    case 5:
                        console.log(aptosQueue);
                        if (!(aptosQueue.queueKey == on_demand_1.ON_DEMAND_MAINNET_QUEUE.toBase58())) return [3 /*break*/, 8];
                        solanaQueue = index_js_1.solanaProgramCache.get(on_demand_1.ON_DEMAND_MAINNET_QUEUE.toBase58());
                        if (!!solanaQueue) return [3 /*break*/, 7];
                        return [4 /*yield*/, (0, on_demand_1.getDefaultQueue)(options === null || options === void 0 ? void 0 : options.solanaRPCUrl)];
                    case 6:
                        solanaQueue = _c.sent();
                        index_js_1.solanaProgramCache.set(on_demand_1.ON_DEMAND_MAINNET_QUEUE.toBase58(), solanaQueue);
                        _c.label = 7;
                    case 7: return [3 /*break*/, 12];
                    case 8:
                        if (!(aptosQueue.queueKey == on_demand_1.ON_DEMAND_DEVNET_QUEUE.toBase58())) return [3 /*break*/, 11];
                        solanaQueue = index_js_1.solanaProgramCache.get(on_demand_1.ON_DEMAND_DEVNET_QUEUE.toBase58());
                        if (!!solanaQueue) return [3 /*break*/, 10];
                        return [4 /*yield*/, (0, on_demand_1.getDefaultDevnetQueue)(options === null || options === void 0 ? void 0 : options.solanaRPCUrl)];
                    case 9:
                        solanaQueue = _c.sent();
                        index_js_1.solanaProgramCache.set(on_demand_1.ON_DEMAND_DEVNET_QUEUE.toBase58(), solanaQueue);
                        _c.label = 10;
                    case 10: return [3 /*break*/, 12];
                    case 11: throw new Error("[fetchUpdateTx]: QUEUE NOT FOUND");
                    case 12:
                        // fail out if we can't load the queue
                        if (!solanaQueue) {
                            throw new Error("Could not load the Switchboard Queue - Queue pubkey: ".concat(aptosQueue.queueKey));
                        }
                        crossbarClient = (_a = options === null || options === void 0 ? void 0 : options.crossbarClient) !== null && _a !== void 0 ? _a : new on_demand_1.CrossbarClient((_b = options === null || options === void 0 ? void 0 : options.crossbarUrl) !== null && _b !== void 0 ? _b : "https://crossbar.switchboard.xyz");
                        return [4 /*yield*/, crossbarClient
                                .fetch(feedConfigs.feedHash)
                                .then(function (res) { return res.jobs.map(function (job) { return on_demand_1.OracleJob.fromObject(job); }); })];
                    case 13:
                        jobs = _c.sent();
                        fetchUpdateData = function () { return __awaiter(_this, void 0, void 0, function () {
                            var _a, responses, failures, validOracles, validResponses, updates, _loop_1, this_1, _i, validResponses_1, response, state_1, updateTx;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0: return [4 /*yield*/, solanaQueue.fetchSignatures({
                                            jobs: jobs,
                                            // Make this more granular in the canonical fetch signatures (within @switchboard-xyz/on-demand)
                                            maxVariance: Math.floor(feedConfigs.maxVariance / 1e9),
                                            minResponses: feedConfigs.minResponses,
                                            numSignatures: feedConfigs.minSampleSize,
                                            // blockhash checks aren't possible yet on SUI
                                            recentHash: common_1.bs58.encode(new Uint8Array(32)),
                                            useTimestamp: true,
                                        })];
                                    case 1:
                                        _a = _b.sent(), responses = _a.responses, failures = _a.failures;
                                        validOracles = new Set(aptosQueue.existingOracles.map(function (o) { return o.oracleKey; }));
                                        validResponses = responses.filter(function (r) {
                                            return validOracles.has(common_1.bs58.encode(Buffer.from(r.oracle_pubkey, "hex")));
                                        });
                                        // if we have no valid responses (or not enough), fail out
                                        if (!validResponses.length ||
                                            validResponses.length < feedConfigs.minSampleSize) {
                                            // maybe retry by recursing into the same function / add a retry count
                                            throw new Error("Not enough valid oracle responses.");
                                        }
                                        updates = [];
                                        _loop_1 = function (response) {
                                            var oracle = aptosQueue.existingOracles.find(function (o) {
                                                return o.oracleKey == common_1.bs58.encode(Buffer.from(response.oracle_pubkey, "hex"));
                                            });
                                            if (!oracle) {
                                                return { value: void 0 };
                                            }
                                            // Get the data from the response
                                            var signature = Array.from(Buffer.from(response.signature, "base64"));
                                            signature.push(response.recovery_id);
                                            var aggregatorAddress = this_1.address;
                                            var timestamp = response.timestamp;
                                            var value = response.success_value;
                                            // build update array
                                            var updateBytes = [];
                                            // discriminator
                                            updateBytes.push(1);
                                            // format the feed address
                                            var feedAddress = Array.from(Buffer.from(aggregatorAddress.startsWith("0x") ? aggregatorAddress.slice(2) : aggregatorAddress, "hex"));
                                            if (feedAddress.length < 32) {
                                                feedAddress.unshift(0);
                                            }
                                            // push feed address
                                            updateBytes.push.apply(updateBytes, feedAddress);
                                            // push value
                                            updateBytes.push.apply(updateBytes, Array.from(this_1.i128ToUint8Array(BigInt(value))));
                                            // push r
                                            updateBytes.push.apply(updateBytes, signature.slice(0, 32));
                                            // push s
                                            updateBytes.push.apply(updateBytes, signature.slice(32, 64));
                                            // push v
                                            updateBytes.push(signature[64]);
                                            // push block number (zeroed out for now - bytes32 0)
                                            updateBytes.push.apply(updateBytes, Array(8).fill(0));
                                            // push timestamp
                                            var timestampBuffer = Buffer.alloc(8);
                                            timestampBuffer.writeBigInt64BE(BigInt(timestamp), 0);
                                            updateBytes.push.apply(updateBytes, Array.from(timestampBuffer));
                                            // push oracle address
                                            updateBytes.push.apply(updateBytes, Array.from(common_1.bs58.decode(oracle.oracleKey)));
                                            // push the update bytes
                                            updates.push(updateBytes);
                                        };
                                        this_1 = this;
                                        // map the responses into the tx
                                        for (_i = 0, validResponses_1 = validResponses; _i < validResponses_1.length; _i++) {
                                            response = validResponses_1[_i];
                                            state_1 = _loop_1(response);
                                            if (typeof state_1 === "object")
                                                return [2 /*return*/, state_1.value];
                                        }
                                        return [4 /*yield*/, this.client.aptos.transaction.build.simple({
                                                sender: sender,
                                                data: {
                                                    function: "".concat(switchboardAddress, "::update_action::run"),
                                                    functionArguments: [updates],
                                                    typeArguments: [ts_sdk_1.APTOS_COIN],
                                                },
                                                withFeePayer: true,
                                            })];
                                    case 2:
                                        updateTx = _b.sent();
                                        return [2 /*return*/, { responses: responses, failures: failures, updates: updates, updateTx: updateTx }];
                                }
                            });
                        }); };
                        fetchUpdateDataRetries = 0;
                        _c.label = 14;
                    case 14:
                        if (!(fetchUpdateDataRetries < 5)) return [3 /*break*/, 19];
                        _c.label = 15;
                    case 15:
                        _c.trys.push([15, 17, , 18]);
                        return [4 /*yield*/, fetchUpdateData()];
                    case 16:
                        fetchUpdateDataResponse = _c.sent();
                        return [3 /*break*/, 19];
                    case 17:
                        e_1 = _c.sent();
                        fetchUpdateDataRetries++;
                        console.log("Failed to fetch update data, retrying...");
                        return [3 /*break*/, 18];
                    case 18: return [3 /*break*/, 14];
                    case 19:
                        // fail out if we can't fetch the update data
                        if (!fetchUpdateDataResponse) {
                            throw new Error("Failed to fetch update data");
                        }
                        // return the response
                        return [2 /*return*/, fetchUpdateDataResponse];
                }
            });
        });
    };
    Aggregator.parseAggregatorData = function (resource) {
        var data = {
            address: resource.aggregator_address,
            authority: resource.authority,
            createdAt: parseInt(resource.created_at),
            currentResult: {
                maxResult: new bn_js_1.default(resource.current_result.max_result.value).mul(new bn_js_1.default(resource.current_result.max_result.neg ? -1 : 1)),
                maxTimestamp: parseInt(resource.current_result.max_timestamp),
                mean: new bn_js_1.default(resource.current_result.mean.value).mul(new bn_js_1.default(resource.current_result.mean.neg ? -1 : 1)),
                minResult: new bn_js_1.default(resource.current_result.min_result.value).mul(new bn_js_1.default(resource.current_result.min_result.neg ? -1 : 1)),
                minTimestamp: parseInt(resource.current_result.min_timestamp),
                range: new bn_js_1.default(resource.current_result.range.value).mul(new bn_js_1.default(resource.current_result.range.neg ? -1 : 1)),
                result: new bn_js_1.default(resource.current_result.result.value).mul(new bn_js_1.default(resource.current_result.result.neg ? -1 : 1)),
                stdev: new bn_js_1.default(resource.current_result.stdev.value).mul(new bn_js_1.default(resource.current_result.stdev.neg ? -1 : 1)),
            },
            feedHash: resource.feed_hash,
            maxStalenessSeconds: parseInt(resource.max_staleness_seconds),
            maxVariance: parseInt(resource.max_variance),
            minResponses: parseInt(resource.min_responses),
            minSampleSize: parseInt(resource.min_sample_size),
            name: resource.name,
            queue: resource.queue,
            updateState: {
                currIdx: parseInt(resource.update_state.curr_idx),
                results: resource.update_state.results.map(function (r) {
                    var oracle = r.oracle;
                    var value = new bn_js_1.default(r.result.value).mul(r.result.neg ? new bn_js_1.default(-1) : new bn_js_1.default(1));
                    var timestamp = parseInt(r.timestamp);
                    return {
                        oracle: oracle,
                        value: value,
                        timestamp: timestamp,
                    };
                }),
            },
        };
        return data;
    };
    /**
     * Get the feed data object
     */
    Aggregator.prototype.loadData = function () {
        return __awaiter(this, void 0, void 0, function () {
            var switchboardAddress, resources, resource;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.client.fetchState()];
                    case 1:
                        switchboardAddress = (_a.sent()).switchboardAddress;
                        return [4 /*yield*/, this.client.aptos.view({
                                payload: {
                                    function: "".concat(switchboardAddress, "::aggregator::view_aggregator"),
                                    functionArguments: [this.address],
                                },
                            })];
                    case 2:
                        resources = _a.sent();
                        resource = resources[0];
                        // return the data object
                        return [2 /*return*/, Aggregator.parseAggregatorData(resource)];
                }
            });
        });
    };
    /**
     * Load all feeds
     */
    Aggregator.loadAllFeeds = function (switchboardClient) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, switchboardAddress, oracleQueue, resourcesResponse, resources, aggregators;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, switchboardClient.fetchState()];
                    case 1:
                        _a = _b.sent(), switchboardAddress = _a.switchboardAddress, oracleQueue = _a.oracleQueue;
                        return [4 /*yield*/, switchboardClient.aptos.view({
                                payload: {
                                    function: "".concat(switchboardAddress, "::aggregator::view_queue_aggregators"),
                                    functionArguments: [oracleQueue],
                                },
                            })];
                    case 2:
                        resourcesResponse = _b.sent();
                        resources = resourcesResponse[0];
                        aggregators = resources.map(function (resource) { return _this.parseAggregatorData(resource); });
                        return [2 /*return*/, aggregators];
                }
            });
        });
    };
    Aggregator.prototype.i128ToUint8Array = function (value) {
        // Prepare an array of 16 bytes (128 bits).
        var result = new Uint8Array(16);
        // Convert the absolute value to Big-Endian bytes
        var absValue = value < 0 ? -value : value;
        for (var i = 15; i >= 0; i--) {
            result[i] = Number(absValue & BigInt(0xFF));
            absValue = absValue >> BigInt(8);
        }
        // If it's a negative number, apply two's complement
        if (value < 0) {
            for (var i = 0; i < 16; i++) {
                result[i] = ~result[i] & 0xFF;
            }
            // Add one to complete the two's complement
            for (var i = 15; i >= 0; i--) {
                result[i] = (result[i] + 1) & 0xFF;
                if (result[i] !== 0)
                    break; // Stop if there was no overflow
            }
        }
        return result;
    };
    return Aggregator;
}());
exports.Aggregator = Aggregator;
// Alias Aggregator to PullFeed
exports.PullFeed = Aggregator;
//# sourceMappingURL=index.js.map