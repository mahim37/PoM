import { bs58 } from "@switchboard-xyz/common";
export class Queue {
    constructor(client, address) {
        this.client = client;
        this.address = address;
    }
    /**
     * Create a new Queue
     */
    static async initTx(client, sender, options) {
        const { switchboardAddress } = await client.fetchState(options);
        if (options.isGuardianQueue) {
            return client.aptos.transaction.build.simple({
                sender,
                data: {
                    function: `${switchboardAddress}::guardian_queue_init_action::run`,
                    functionArguments: [
                        Array.from(Buffer.from(options.queueKey, "hex")),
                        options.name,
                        options.fee,
                        options.feeRecipient,
                        options.minAttestations,
                        options.oracleValidityLength,
                    ],
                },
            });
        }
        else {
            if (!options.guardianQueue) {
                throw new Error("guardianQueueId is required for non-guardian queues");
            }
            return client.aptos.transaction.build.simple({
                sender,
                data: {
                    function: `${switchboardAddress}::oracle_queue_init_action::run`,
                    functionArguments: [
                        Array.from(Buffer.from(options.queueKey, "hex")),
                        options.name,
                        options.fee,
                        options.feeRecipient,
                        options.minAttestations,
                        options.oracleValidityLength,
                        options.guardianQueue,
                    ],
                },
            });
        }
    }
    /**
     * Queue set configs tx
     */
    async setConfigsTx(sender, options) {
        const { switchboardAddress } = await this.client.fetchState(options);
        return this.client.aptos.transaction.build.simple({
            sender,
            data: {
                function: `${switchboardAddress}::queue_set_configs_action::run`,
                functionArguments: [
                    this.address,
                    options.name,
                    options.fee,
                    options.feeRecipient,
                    options.minAttestations,
                    options.oracleValidityLength,
                ],
            },
        });
    }
    /**
     * Queue set authority tx
     */
    async setAuthorityTx(sender, options) {
        const { switchboardAddress } = await this.client.fetchState(options);
        return this.client.aptos.transaction.build.simple({
            sender,
            data: {
                function: `${switchboardAddress}::queue_set_authority_action::run`,
                functionArguments: [this.address, options.newAuthority],
            },
        });
    }
    /**
     * Queue override oracle tx
     */
    async overrideOracleTx(sender, options) {
        const { switchboardAddress } = await this.client.fetchState(options);
        return this.client.aptos.transaction.build.simple({
            sender,
            data: {
                function: `${switchboardAddress}::queue_override_oracle_action::run`,
                functionArguments: [
                    this.address,
                    options.oracle,
                    Array.from(options.secp256k1Key),
                    Array.from(options.mrEnclave),
                    options.expirationTime,
                ],
            },
        });
    }
    /**
     * Queue add fee type tx
     */
    async addFeeTypeTx(sender, options) {
        const { switchboardAddress } = await this.client.fetchState(options);
        return this.client.aptos.transaction.build.simple({
            sender,
            data: {
                function: `${switchboardAddress}::queue_add_fee_coin_action::run`,
                functionArguments: [this.address],
                typeArguments: [options.feeType],
            },
        });
    }
    /**
     * Queue remove fee type tx
     */
    async removeFeeTypeTx(sender, options) {
        const { switchboardAddress } = await this.client.fetchState(options);
        return this.client.aptos.transaction.build.simple({
            sender,
            data: {
                function: `${switchboardAddress}::queue_remove_fee_coin_action::run`,
                functionArguments: [this.address],
                typeArguments: [options.feeType],
            },
        });
    }
    formatType(type) {
        const decodedModuleName = Buffer.from(type.module_name.slice(2), "hex").toString("utf-8");
        const decodedStructName = Buffer.from(type.struct_name.slice(2), "hex").toString("utf-8");
        return `${type.account_address}::${decodedModuleName}::${decodedStructName}`;
    }
    /**
     * Get the queue data object
     */
    async loadData() {
        const { switchboardAddress } = await this.client.fetchState();
        const resources = await this.client.aptos.view({
            payload: {
                function: `${switchboardAddress}::queue::view_queue`,
                functionArguments: [this.address],
            },
        });
        const resource = resources[0];
        // parse the data into the correct types
        const data = {
            authority: resource.authority,
            existingOracles: resource.all_oracles.map((o) => ({
                oracle: o.oracle,
                oracleKey: bs58.encode(Buffer.from(o.oracle_key.slice(2), "hex")),
            })),
            fee: parseInt(resource.fee),
            feeRecipient: resource.fee_recipient,
            feeTypes: resource.fee_types.map((ft) => this.formatType(ft)),
            guardianQueue: resource.guardian_queue,
            address: this.address,
            lastQueueOverride: parseInt(resource.last_queue_override),
            minAttestations: parseInt(resource.min_attestations),
            name: resource.name,
            oracleValidityLength: parseInt(resource.oracle_validity_length),
            queueKey: bs58.encode(Buffer.from(resource.queue_key.slice(2), "hex")),
        };
        return data;
    }
    async loadOracles() {
        const { switchboardAddress } = await this.client.fetchState();
        const resourcesResponse = await this.client.aptos.view({
            payload: {
                function: `${switchboardAddress}::oracle::view_queue_oracles`,
                functionArguments: [this.address],
            },
        });
        if (resourcesResponse.length === 0) {
            return [];
        }
        const resources = resourcesResponse[0];
        const oracles = resources.map((resource) => {
            return {
                expirationTime: parseInt(resource.expiration_time),
                address: resource.oracle_address,
                mrEnclave: resource.mr_enclave,
                oracleKey: bs58.encode(Buffer.from(resource.oracle_key.slice(2), "hex")),
                queue: resource.queue,
                queueKey: bs58.encode(Buffer.from(resource.queue_key.slice(2), "hex")),
                secp256k1Key: resource.secp256k1_key,
                validAttestations: resource.valid_attestations,
            };
        });
        return oracles;
    }
}
//# sourceMappingURL=index.js.map