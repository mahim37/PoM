import { TTLCache } from "@brokerloop/ttlcache";
import { ON_DEMAND_DEVNET_QUEUE as SWITCHBOARD_DEVNET_QUEUE, ON_DEMAND_MAINNET_QUEUE as SWITCHBOARD_MAINNET_QUEUE, } from "@switchboard-xyz/on-demand";
import { Network, MoveVector, } from "@aptos-labs/ts-sdk";
import { default as axios } from "axios";
export * from "./aggregator/index.js";
export * from "./oracle/index.js";
export * from "./queue/index.js";
export * from "@switchboard-xyz/common";
export const ON_DEMAND_MAINNET_QUEUE_KEY = SWITCHBOARD_MAINNET_QUEUE.toBase58();
export const ON_DEMAND_DEVNET_QUEUE_KEY = SWITCHBOARD_DEVNET_QUEUE.toBase58();
export const ON_DEMAND_MAINNET_ADDRESS = "0xfea54925b5ac1912331e2e62049849b37842efaea298118b66f85a59057752b8";
export const ON_DEMAND_MAINNET_QUEUE = "0x7fdf7235bf3bd872ad093927deb2ff5f1645d1b6dabbfd4a03c3e0442788ce12";
export const ON_DEMAND_MAINNET_GUARDIAN_QUEUE = "0x3434a45114f5f8fc577557a9a3dda54c1799fee5271313f2599a1093c4a8ba01";
export const ON_DEMAND_TESTNET_ADDRESS = "0x4fc1809ffb3c5ada6b4e885d4dbdbeb70cbdd99cbc0c8485965d95c2eab90935";
export const ON_DEMAND_TESTNET_QUEUE = "0xe898232691709ed4f47827a100aac2ca8ea5b27692b5d694b00cb4b2c714e760";
export const ON_DEMAND_TESTNET_GUARDIAN_QUEUE = "0x17ce931b15d5c4ca8f8e6a5b6b84e2aee44002e5fc5cb4cf00817bb462b56c4a";
export const ON_DEMAND_MOVEMENT_PORTO_ADDRESS = "0xfa416028d48a85cd7791c8a93c438ce8a750af333a53fde55b276fd4aa16275f";
export const ON_DEMAND_MOVEMENT_PORTO_QUEUE = "0x4e445d2968329979b34df2606a65e962ad15a540885fdcbb19eaf7a2a5bf4a22";
export const ON_DEMAND_MOVEMENT_PORTO_GUARDIAN_QUEUE = "0x63be642227d71ba56713d2cdb2efd13de0fb7d9783761e4d7f18327c7336f994";
// ==============================================================================
// Caching for Fetch Update Ix
// 1 min cache for sui cache
export const aptosQueueCache = new TTLCache({
    ttl: 1000 * 60,
});
// 5 min solana queue cache - reloads the sol program every 5 minutes max
export const solanaProgramCache = new TTLCache({
    ttl: 1000 * 60 * 5,
});
export class SwitchboardClient {
    constructor(aptos, chain) {
        this.aptos = aptos;
        this.chain = chain;
        this.state = this.fetchState();
    }
    /**
     * Fetch the correct addresses for the current network
     * @param retries Number of retries to fetch the state
     */
    async fetchState(options, retries = 3) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (retries <= 0) {
            throw new Error("Failed to fetch Switchboard state after multiple attempts");
        }
        const isMainnet = this.aptos.config.network === Network.MAINNET;
        const isAptos = this.chain === "aptos" || !this.chain;
        try {
            if (Network.MAINNET === this.aptos.config.network && isAptos) {
                return {
                    switchboardAddress: (_a = options === null || options === void 0 ? void 0 : options.switchboardAddress) !== null && _a !== void 0 ? _a : ON_DEMAND_MAINNET_ADDRESS,
                    guardianQueue: (_b = options === null || options === void 0 ? void 0 : options.guardianQueue) !== null && _b !== void 0 ? _b : ON_DEMAND_MAINNET_GUARDIAN_QUEUE,
                    oracleQueue: (_c = options === null || options === void 0 ? void 0 : options.oracleQueue) !== null && _c !== void 0 ? _c : ON_DEMAND_MAINNET_QUEUE,
                    mainnet: isMainnet,
                };
            }
            else if (Network.TESTNET === this.aptos.config.network && isAptos) {
                return {
                    switchboardAddress: (_d = options === null || options === void 0 ? void 0 : options.switchboardAddress) !== null && _d !== void 0 ? _d : ON_DEMAND_TESTNET_ADDRESS,
                    guardianQueue: (_e = options === null || options === void 0 ? void 0 : options.guardianQueue) !== null && _e !== void 0 ? _e : ON_DEMAND_TESTNET_GUARDIAN_QUEUE,
                    oracleQueue: (_f = options === null || options === void 0 ? void 0 : options.oracleQueue) !== null && _f !== void 0 ? _f : ON_DEMAND_TESTNET_QUEUE,
                    mainnet: isMainnet,
                };
            }
            else if (this.chain === "porto") {
                return {
                    switchboardAddress: (_g = options === null || options === void 0 ? void 0 : options.switchboardAddress) !== null && _g !== void 0 ? _g : ON_DEMAND_MOVEMENT_PORTO_ADDRESS,
                    guardianQueue: (_h = options === null || options === void 0 ? void 0 : options.guardianQueue) !== null && _h !== void 0 ? _h : ON_DEMAND_MOVEMENT_PORTO_GUARDIAN_QUEUE,
                    oracleQueue: (_j = options === null || options === void 0 ? void 0 : options.oracleQueue) !== null && _j !== void 0 ? _j : ON_DEMAND_MOVEMENT_PORTO_QUEUE,
                    mainnet: isMainnet,
                };
            }
        }
        catch (error) {
            console.error("Error fetching Switchboard state, retrying...");
            return this.fetchState(options, retries - 1);
        }
    }
}
export async function axiosAptosClient(requestOptions) {
    var _a, _b, _c, _d;
    const { params, method, url, headers, body } = requestOptions;
    const customHeaders = {
        ...headers,
        customClient: true,
    };
    const config = {
        url,
        method,
        headers: customHeaders,
        data: body,
        params,
    };
    try {
        const response = await axios(config);
        return {
            status: response.status,
            statusText: response.statusText,
            data: response.data,
            headers: response.headers,
            config: response.config,
            request: response.request,
        };
    }
    catch (error) {
        if (axios.isAxiosError(error)) {
            const errorMessage = (_b = (_a = error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message;
            const errorCode = (_d = (_c = error.response) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.error_code;
            if (errorMessage && errorCode) {
                console.error(`Error: ${errorMessage} (Code: ${errorCode})`);
            }
            else {
                console.error("An unknown error occurred.");
            }
        }
        else {
            console.error("An unexpected error occurred:", error);
        }
    }
}
export async function waitForTx(aptos, transactionHash, maxRetries = 5, initialDelay = 500 // Start with a half-second delay
) {
    let retries = 0;
    let delay = initialDelay;
    while (retries < maxRetries) {
        try {
            const result = await aptos.waitForTransaction({
                transactionHash,
                options: {
                    timeoutSecs: 30,
                    checkSuccess: true,
                },
            });
            return result;
        }
        catch (error) {
            await new Promise((resolve) => setTimeout(resolve, delay));
            delay *= 2; // Exponential backoff: double the delay
            retries++;
        }
    }
    throw new Error(`Transaction not found after ${maxRetries} retries.`);
}
export function updateToBCS(update) {
    return new MoveVector(update.map((u) => MoveVector.U8(u)));
}
//# sourceMappingURL=index.js.map